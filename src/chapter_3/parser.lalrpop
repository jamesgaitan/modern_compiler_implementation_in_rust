use std::str::FromStr;

use crate::chapter_3::ast::{Atom, BinOp, BinOpExpr, Expr, FunctionCall, Statement};

grammar;

Num: i32 = {
    <s:r"[0-9]+"> => s.parse().unwrap(),
};

Real: f32 = {
    <s:r"[0-9]+\.[0-9]+"> => s.parse().unwrap(),
};

Identifier: String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string(),
};

pub Atom: Atom = {
    "True" => Atom::Boolean(true),
    "False" => Atom::Boolean(false),
    Identifier => Atom::Id(<>),
    Num => Atom::Int(<>),
    Real => Atom::Float(<>),
};

pub Expr: Expr = {
    "(" <t:Term> ")" => t,
    Atom => Expr::Atom(<>),
    <f:FunctionCall> => Expr::FunctionCall(f),
};

pub Factor: Expr = {
    <l:Factor> "*" <r:Expr> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Mul, right: r})),
    <l:Factor> "/" <r:Expr> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Div, right: r})),
    Expr,
};

pub Term: Expr = {
    <l:Term> "+" <r:Factor> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Add, right: r})),
    <l:Term> "-" <r:Factor> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Sub, right: r})),
    Factor,
};

pub FunctionCall: FunctionCall = {
    <i:Identifier> "(" <a:CommaSeparated<Expr>> ")" => FunctionCall {name: i, arguments: a},
};

CommaSeparated<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Statement: Statement = {
    <e:Expr> ";" => Statement::Expr(e),
    <i:Initialization> ";" => i,
    <a:Assignment> ";" => a,
    <i:IfBlock> => i,
    <f:ForLoop> => f,
    <w:WhileLoop> => w
};

pub Initialization: Statement = { 
    "let" <i:Identifier> "=" <e:Expr> => Statement::Initialization { id: i, mutable: false, var_type: "".to_string(), val: e },
    "let mut" <i:Identifier> "=" <e:Expr> => Statement::Initialization { id: i, mutable: true, var_type: "".to_string(), val: e },
    "let" <i:Identifier> ":" <t:Type> "=" <e:Expr> => Statement::Initialization { id: i, mutable: false, var_type: t.to_string(), val: e },
    "let mut" <i:Identifier> ":" <t:Type> "=" <e:Expr> => Statement::Initialization { id: i, mutable: true, var_type: t.to_string(), val: e },
};

pub Assignment: Statement = { 
    <i:Identifier> "=" <e:Expr> => Statement::Assignment(i, e),
};

pub Type = { 
    "int",
    "float",
    "bool",
    "char",
    "string",
};

pub CodeBlock: Vec<Statement> = { 
    "{" <v:(<Statement>)+> "}" => v,
};

pub IfBlock: Statement = { 
    "if" <e:Expr> <c:CodeBlock> => Statement::IfBlock(e, c),
    "if" <e:Expr> <c:CodeBlock> "else" <ec:CodeBlock> => Statement::IfElseBlock(e, c, ec)
};

pub ForLoop: Statement = { 
    "for" <e1: Expr> ";" <e2: Expr> ";" <e3: Expr> <c: CodeBlock> => Statement::ForLoop(e1, e2, e3, c),
};

pub WhileLoop: Statement = { 
    "while" <e: Expr> <c: CodeBlock> => Statement::WhileLoop(e, c),
};
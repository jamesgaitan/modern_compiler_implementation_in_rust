use std::str::FromStr;

use crate::chapter_3::ast::{Atom, BinOp, BinOpExpr, Expr, FunctionCall, Statement};

grammar;

Num: i32 = {
    <s:r"[0-9]+"> => s.parse().unwrap(),
};

Real: f32 = {
    <s:r"[0-9]+\.[0-9]+"> => s.parse().unwrap(),
};

Identifier: String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string(),
};

pub Atom: Atom = {
    "True" => Atom::Boolean(true),
    "False" => Atom::Boolean(false),
    Identifier => Atom::Id(<>),
    Num => Atom::Int(<>),
    Real => Atom::Float(<>),
};

pub Expr: Expr = {
    "(" <t:Term> ")" => t,
    Atom => Expr::Atom(<>),
    <f:FunctionCall> => Expr::FunctionCall(f),
};

pub Factor: Expr = {
    <l:Factor> "*" <r:Expr> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Mul, right: r})),
    <l:Factor> "/" <r:Expr> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Div, right: r})),
    Expr,
};

pub Term: Expr = {
    <l:Term> "+" <r:Factor> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Add, right: r})),
    <l:Term> "-" <r:Factor> => Expr::BinOpExpr(Box::new(BinOpExpr {left: l, op: BinOp::Sub, right: r})),
    Factor,
};

pub FunctionCall: FunctionCall = {
    <i:Identifier> "(" <a:CommaSeparated<Expr>> ")" => FunctionCall {name: i, arguments: a},
};

CommaSeparated<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Statement: Statement = {
    <e:Expr> ";" => Statement::Expr,
    <i:Initialization> ";" => i,
    <a:Assignment> ";" => a,
    <i:IfBlock> => i,
    <f:ForLoop> => f,
    <w:WhileLoop> => w
};

pub Initialization: Statement = { 
    "let" "mut"? <Identifier> "=" <Expr> => Statement::Initialization,
    "let" "mut"? <Identifier> ":" <Type> "=" <Expr> => Statement::Initialization,
};

pub Assignment: Statement = { 
    <Identifier> "=" <Expr> => Statement::Assignment,
};

pub Type = { 
    "int",
    "float",
    "bool",
    "char",
    "string",
};

pub CodeBlock: () = { 
    "{" (<Statement>)+ "}",
};

pub IfBlock: Statement = { 
    "if" <Expr> <CodeBlock> ("elseif" <Expr> <CodeBlock>)* ("else" <CodeBlock>)? => Statement::IfBlock,
};

pub ForLoop: Statement = { 
    "for" <Expr> ";" <Expr> ";" <Expr> <CodeBlock> => Statement::ForLoop,
};

pub WhileLoop: Statement = { 
    "while" <Expr> <CodeBlock> => Statement::WhileLoop,
};